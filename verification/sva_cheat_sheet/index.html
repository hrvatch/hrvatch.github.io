<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      SystemVerilog Assertions cheat sheet &middot; Critical Path blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-abstract-dark-wooden">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Critical Path blog
        </a>
      </h1>
      <p class="lead">A personal blog that contains stuff of interest to Hrvoje Butina. Deep dives into ASIC design & verification. And some shallow dives into the embedded and low-level development.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="https://github.com/hrvatch">GitHub project</a>
    </nav>

    <p>&copy; 2025. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">SystemVerilog Assertions cheat sheet</h1>
  <span class="post-date">01 Nov 2025</span>
  <h2 id="constructs-not-recommended-for-formal">Constructs not recommended for formal</h2>
<p>This is based upon the IEEE 1800-2017 standard (LRM).</p>

<p><code class="language-plaintext highlighter-rouge">throughout</code>
<code class="language-plaintext highlighter-rouge">or</code>
<code class="language-plaintext highlighter-rouge">and</code>
<code class="language-plaintext highlighter-rouge">within</code>
<code class="language-plaintext highlighter-rouge">expect</code>
<code class="language-plaintext highlighter-rouge">first_match()</code>
<code class="language-plaintext highlighter-rouge">if property else property</code>
<code class="language-plaintext highlighter-rouge">sequence.triggered</code>
<code class="language-plaintext highlighter-rouge">sequence[-&gt;N]</code>
<code class="language-plaintext highlighter-rouge">sequence[=N]</code></p>

<p>Local Variables
Immediate Assertions</p>

<h2 id="constructs-to-use-with-caution">Constructs to use with caution</h2>
<pre><code class="language-systemverilog">sequence[*N]
$past(expr, N)
</code></pre>
<p>In both cases keep <code class="language-plaintext highlighter-rouge">N</code> as small as possible. It’s recommended to model <code class="language-plaintext highlighter-rouge">$past()</code> with Auxiliary Code instead.</p>

<h2 id="declarations">Declarations</h2>
<h3 id="sequence-declaration">Sequence declaration</h3>
<p>Declares a sequence expression that can be used in property declarations. Local variables are permitted,</p>

<pre><code class="language-systemverilog">sequence identifier [ argument_list ] ;
	sequence_expr [ ; ]
endsequence [ : identifier ]
</code></pre>

<p>Example:</p>
<pre><code class="language-systemverilog">sequence SEQ1;
	A ##1 B ##1 C;
endsequence

sequence SEQ2(LEN, SIG);
	D ##1 E[*LEN] ##1 SIG;
endsequence
</code></pre>

<p>Recommended to define, or infer, sequence lock at instantiation and not at declaration. A sequence is a series of Boolean expressions evaluated over time. A sequence of length one cycle is the same as a Boolean expression.</p>

<h3 id="property-declaration">Property declaration</h3>
<pre><code class="language-systemverilog">property identifier [ argument_list ] ;
	[ clock_expr ] [ disable_clause ]
	property_expr ;
endproperty
</code></pre>

<p>Example:</p>
<pre><code class="language-systemverilog">property P1 (R, S, T) ;
	@(posedge clk) disable iff ( !rst_n )
	A |=&gt; R ##1 S &amp;&amp; T;
endproperty

property P1A;
	REQ |=&gt; s_eventually GNT;
endproperty
</code></pre>

<h2 id="verification-directives">Verification directives</h2>
<p>A property declaration is merely a definition of behavior. Nothing gets checked until we have given a <em>verification directive</em> to the tool which states what should be done with that behavior. All properties must have a clock defined explicitly or via a default clock declaration.</p>

<h3 id="assert-directive">Assert directive</h3>
<p>Directive to the tool to ensure that the property holds, is true, under all circumstances (safety check).</p>

<p>Syntax:</p>
<pre><code class="language-systemverilog">label : assert property (prop_expr)
</code></pre>

<p>Examples:</p>
<pre><code class="language-systemverilog">P1_INST : assert property (P1(SIG1, SIG2, S3));
P2 : assert property ( @(posedge clk) A |-&gt; B );
P3 : assert property ( ERROR_CNT != 10 );
P1A_INS : assert property (@(posedge clka) (P1A) );

// TODO: Add example where there is a property declaration, and then this property is used in an assertion
</code></pre>

<h3 id="assume-directive">Assume directive</h3>
<p>Directive to the tool to limit the behavior of the design under test (DUT) inputs to the behavior specified. Also known as constraints. Assume directives in the simulation are treated as assert directives.</p>

<p>Syntax:</p>
<pre><code class="language-systemverilog">label : assume property (prop_expr)
</code></pre>
<p>Examples:</p>
<pre><code class="language-systemverilog">P4 : assume property (req &amp;&amp; !gnt |=&gt; req)
P5 : assume property ( @(posedge clk3) not(full &amp;&amp; empty) );

// TODO: Add an example where there is a property declaration, and then this property is used in an assumption
</code></pre>

<h3 id="cover-directive">Cover directive</h3>
<p>In the formal verification, a cover directive instructs the formal tool to find at least one valid execution trace in which a specified sequence of events or conditions can occur, given the design logic and any active <strong>assumptions</strong>  (constraints).
Syntax:</p>
<pre><code class="language-systemverilog">label : cover property (prop_expr)
</code></pre>
<p>Examples:</p>
<pre><code class="language-systemverilog">C1 : cover sequence (full ##[+] empty );
C2 : cover property ( @(posedge clk) (SEQ1) );

// TODO: Add an example where there is a sequence declaration and then this sequence is used in a cover
</code></pre>
<p>For <code class="language-plaintext highlighter-rouge">cover property</code> it is recommended for <code class="language-plaintext highlighter-rouge">prop_expr</code> to only be a sequence, i.e. not contain implication operators <code class="language-plaintext highlighter-rouge">|-&gt;</code> or <code class="language-plaintext highlighter-rouge">|=&gt;</code> and the cover directive states <code class="language-plaintext highlighter-rouge">cover sequence</code> instead of <code class="language-plaintext highlighter-rouge">cover property</code></p>

<h2 id="cycle-delays">Cycle delays</h2>
<p>Specifies the number of clock ticks from the current clock tick until the next specified behavior occurs.</p>

<p>Syntax:</p>
<pre><code class="language-systemverilog">##[N:M]
##N
</code></pre>

<p>N and M are constants know at elaboration. M can be the symbol $ meaning “infinity”. M &gt;= N. M and N can be 0.
Example:</p>
<pre><code class="language-systemverilog">P6: assert property( A |=&gt; B ##[0:$] C );
P7: assert property( A |=&gt; ##3 C );
</code></pre>
<h2 id="implication-operators---">Implication operators (<code class="language-plaintext highlighter-rouge">|-&gt;</code>, <code class="language-plaintext highlighter-rouge">|=&gt;</code>)</h2>

<p>Implication operators define a relationship between an <strong>enabling condition</strong> and a <strong>fulfilling condition</strong>.
A property using an implication operator holds true if either:</p>
<ol>
  <li>The fulfilling condition occurs as a consequence of the enabling condition, or</li>
  <li>The enabling condition <strong>never occurs</strong>.</li>
</ol>

<h3 id="overlapping-implication--">Overlapping Implication (<code class="language-plaintext highlighter-rouge">|-&gt;</code>)</h3>
<p>Syntax:</p>

<pre><code class="language-systemverilog">sequence_expr |-&gt; property_expr`
</code></pre>

<p>This property holds true under the following conditions:</p>
<ol>
  <li>If <code class="language-plaintext highlighter-rouge">sequence_expr</code> completes then <code class="language-plaintext highlighter-rouge">property_expr</code> <strong>starts in the same cycle</strong> and eventually completes.</li>
  <li><code class="language-plaintext highlighter-rouge">seqeunce_expr</code> never completes.
Example:
    <pre><code class="language-systemverilog">P8: assert property (A ##1 B |-&gt; C ##1 D );
</code></pre>
    <p><code class="language-plaintext highlighter-rouge">P8</code> passes if the following sequence is observed:</p>
    <pre><code class="language-systemverilog">(A ##1 (B &amp;&amp; C) ##1 D);
</code></pre>
  </li>
</ol>

<h3 id="non-overlapping-implication-">Non-Overlapping Implication (<code class="language-plaintext highlighter-rouge">|=&gt;</code>)</h3>
<p>Syntax:</p>
<pre><code class="language-systemverilog">sequence_expr |=&gt; property_expr 
</code></pre>
<p>This property holds true under the following conditions:</p>
<ol>
  <li>If <code class="language-plaintext highlighter-rouge">sequence_expr</code> completes then <code class="language-plaintext highlighter-rouge">property_expr</code> <strong>starts in the next cycle</strong> and eventually completes.</li>
  <li><code class="language-plaintext highlighter-rouge">sequence_expr</code> never completes.
Example:
    <pre><code class="language-systemverilog">P9: assert property ( A ##1 B |=&gt; C ##1 D );
</code></pre>
    <p><code class="language-plaintext highlighter-rouge">P9</code> passes if the following sequence is observed:</p>
    <pre><code class="language-systemverilog">(A ##1 B ##1 C ##1 D);
</code></pre>
    <h3 id="nesting-implication-operators">Nesting implication operators</h3>
  </li>
</ol>

<p>It is <strong>not recommended</strong> to nest implication operators, as it can easily become confusing: For example:</p>
<pre><code class="language-systemverilog">P10: assert property (A |=&gt; B |=&gt; C );
</code></pre>
<p>This is exactly equivalent to:</p>
<pre><code class="language-systemverilog">P10_EQUIVALENT : assert property (A ##1 B |=&gt; C);
</code></pre>
<p><code class="language-plaintext highlighter-rouge">P10</code> or <code class="language-plaintext highlighter-rouge">P10_EQUIVALENT</code> would <strong>not fail</strong> if the sequence <code class="language-plaintext highlighter-rouge">(A ##1 !B)</code> is observed.</p>
<h2 id="disabling-properties">Disabling properties</h2>
<p>Syntax:</p>
<pre><code class="language-systemverilog">disable iff (boolean_expr)
</code></pre>
<p>When <code class="language-plaintext highlighter-rouge">boolean_expr</code> is <strong>true</strong>, the property is <strong>temporarily disabled</strong>, and all active checks or pending evaluations for that property (including overlapping ones) are <strong>canceled</strong>.</p>

<p>For example, if a property checks that a <em>request</em> must eventually be followed by a <em>grant</em>, we’d usually want a <strong>reset</strong> to clear any pending request-to-grant expectations.<br />
After reset, new requests start fresh obligations.
Example:</p>
<pre><code class="language-systemverilog">P11: assert property (@(posedge clk) disable iff (!rst_n) req |=&gt; ##[*] gnt);
</code></pre>

<h3 id="default-disable">Default Disable</h3>
<p>If the same disable condition applies to many properties, it can be defined once as a <strong>default disable</strong> instead of repeating it for each property.</p>
<pre><code class="language-systemverilog">default disable iff (boolean_expr);
</code></pre>
<p>This default disable applies to all properties, in the current scope only, which do not have an explicit <code class="language-plaintext highlighter-rouge">disable iff</code> defined:</p>
<pre><code class="language-systemverilog">default disable iff (CANCEL)
P12: assert property(@(posedge clk) disable iff (!rst_n) A |=&gt; B);
P13: assert property(@(posedge clk) C |=&gt; D);
</code></pre>
<p>In this example:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">P12</code> uses its <strong>own</strong> disable condition (<code class="language-plaintext highlighter-rouge">!rst_n</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">P13</code> uses the <strong>default</strong> disable condition (<code class="language-plaintext highlighter-rouge">CANCEL</code>)</li>
</ul>

<p>Both <code class="language-plaintext highlighter-rouge">default disable iff</code> and explicit <code class="language-plaintext highlighter-rouge">disable iff</code> are asynchronous — they take effect immediately, regardless of the property’s clocking event.</p>

<h2 id="clocking-properties">Clocking Properties</h2>

<ul>
  <li>Every SVA property must be <strong>clocked</strong> — unlocked properties are not allowed.</li>
  <li>The clock can come from one of the following:
    <ol>
      <li>An <strong>explicit clocking event</strong> when the property is declared</li>
      <li>An <strong>explicit clocking event</strong> when the property is instantiated</li>
      <li>A <code class="language-plaintext highlighter-rouge">default clocking</code> declaration</li>
    </ol>
  </li>
  <li>An <strong>explicit clock declaration</strong> always overrides the <code class="language-plaintext highlighter-rouge">default clocking</code>.</li>
  <li>Sequences without an explicit clock inherit the clock from their <strong>parent property</strong>.</li>
  <li><code class="language-plaintext highlighter-rouge">default clocking</code> applies only within its <strong>current scope</strong>.</li>
  <li>Only one <code class="language-plaintext highlighter-rouge">default clocking</code> declaration is allowed per scope.</li>
</ul>

<p>Example:</p>
<pre><code class="language-systemverilog">default clocking MYCLK @(posedge clk);
endclocking

property P14;
  A |=&gt; B;
endproperty

property P15;
  @(posedge clk1) A |=&gt; B;
endproperty

P14_A : assert property (@(posedge clk2) P14);
P14_B : assert property (P14);
P15_A : assert property (P15);

P16: assert property (@(posedge clk3) A |-&gt; B);
P17: assert property (C |-&gt; D);
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">P14_A</code> uses <strong>clk2</strong>, overriding all others.</li>
  <li><code class="language-plaintext highlighter-rouge">P14_B</code> uses the <strong>default clock</strong> (<code class="language-plaintext highlighter-rouge">posedge clk</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">P15_A</code> uses the <strong>explicit clock</strong> defined in <code class="language-plaintext highlighter-rouge">P15</code> (<code class="language-plaintext highlighter-rouge">clk1</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">P16</code> uses <strong>clk3</strong> (explicit).</li>
  <li><code class="language-plaintext highlighter-rouge">P17</code> inherits the <strong>default clock</strong>.</li>
</ul>

<h2 id="builtin-functions">Builtin Functions</h2>

<p>| Function           | Description                                                     |
| —————— | ————————————————————— |
| <code class="language-plaintext highlighter-rouge">$past(expr, N)</code>   | Value of <code class="language-plaintext highlighter-rouge">expr</code> N cycles ago (defaults to 1 if <code class="language-plaintext highlighter-rouge">N</code> is omitted). |
| <code class="language-plaintext highlighter-rouge">$rose(expr)</code>      | TRUE when <code class="language-plaintext highlighter-rouge">expr</code> transitions from 0 → 1.                        |
| <code class="language-plaintext highlighter-rouge">$fell(expr)</code>      | TRUE when <code class="language-plaintext highlighter-rouge">expr</code> transitions from 1 → 0.                        |
| <code class="language-plaintext highlighter-rouge">$stable(expr)</code>    | TRUE if <code class="language-plaintext highlighter-rouge">expr</code> has not changed since the previous cycle.        |
| <code class="language-plaintext highlighter-rouge">$onehot(expr)</code>    | TRUE if exactly one bit of <code class="language-plaintext highlighter-rouge">expr</code> is 1.                         |
| <code class="language-plaintext highlighter-rouge">$onehot0(expr)</code>   | TRUE if zero or one bit of <code class="language-plaintext highlighter-rouge">expr</code> is 1.                         |
| <code class="language-plaintext highlighter-rouge">$isunknown(expr)</code> | TRUE if any bit of <code class="language-plaintext highlighter-rouge">expr</code> is X or Z.                            |
| <code class="language-plaintext highlighter-rouge">$countones(expr)</code> | Returns the number of bits in <code class="language-plaintext highlighter-rouge">expr</code> that are 1.                |</p>
<h2 id="repetition">Repetition</h2>
<p>Repetition operators specify <strong>how many times</strong> a sequence element must occur and whether occurrences must be <strong>consecutive</strong> or can be <strong>spread apart</strong>.</p>

<pre><code class="language-systemverilog">[* const_or_range_expression]
</code></pre>
<p><strong>Consecutive repetition</strong> — the expression must be TRUE for a specified number of <strong>consecutive cycles</strong>.</p>

<p>Example:</p>
<pre><code class="language-systemverilog">(a[*2] ##2 b[*2]) |=&gt; d
</code></pre>
<p><code class="language-plaintext highlighter-rouge">a</code> must hold for 2 cycles in a row, then after 2 cycles, <code class="language-plaintext highlighter-rouge">b</code> must hold for 2 cycles in a row.</p>

<pre><code class="language-systemverilog">[-&gt; const_or_range_expression]
</code></pre>
<p><strong>Goto repetition</strong> — looks for the <strong>Nth occurrence</strong> of a sequence element and then continues from there.<br />
This operator <em>skips ahead</em> until the given count of matches has been reached.</p>

<p>Example:</p>
<pre><code class="language-systemverilog">a ##1 b[-&gt;5] ##1 c
</code></pre>
<p>Matches when:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">a</code> occurs</li>
  <li>then the <strong>5th occurrence</strong> of <code class="language-plaintext highlighter-rouge">b</code> (not necessarily consecutive)</li>
  <li>then <code class="language-plaintext highlighter-rouge">c</code> occurs one cycle later</li>
</ul>

<p>So <code class="language-plaintext highlighter-rouge">b</code> may appear several times, but the property only matches when the <strong>5th <code class="language-plaintext highlighter-rouge">b</code></strong> is seen.</p>

<pre><code class="language-systemverilog">[= const_or_range_expression]
</code></pre>
<p><strong>Non-consecutive repetition</strong> — the expression must be TRUE a given number of times,<br />
but <strong>not necessarily on consecutive cycles</strong>.<br />
Other conditions may appear between repetitions.</p>

<p>Example:</p>
<pre><code class="language-systemverilog">s1 |=&gt; (b [=5] ##1 c)
</code></pre>
<p>After <code class="language-plaintext highlighter-rouge">s1</code> completes:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">b</code> must be TRUE <strong>five times in total</strong>,</li>
  <li>these occurrences can be <strong>spread out</strong> in time,</li>
  <li>and after that, <code class="language-plaintext highlighter-rouge">c</code> must occur one cycle later.</li>
</ul>

<h3 id="shortcuts">Shortcuts</h3>

<table>
  <thead>
    <tr>
      <th>Notation</th>
      <th>Equivalent Form</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">R[*]</code></td>
      <td><code class="language-plaintext highlighter-rouge">R[*0:$]</code></td>
      <td>Repeat zero or more times</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">##[*]</code></td>
      <td><code class="language-plaintext highlighter-rouge">##[0:$]</code></td>
      <td>Delay zero or more cycles</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">R[+]</code></td>
      <td><code class="language-plaintext highlighter-rouge">R[*1:$]</code></td>
      <td>Repeat one or more times</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">##[+]</code></td>
      <td><code class="language-plaintext highlighter-rouge">##[1:$]</code></td>
      <td>Delay one or more cycles</td>
    </tr>
  </tbody>
</table>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/weather-station/weather_station_part2/">
            Weather and air quality station based on Raspberry Pi Pico2W and E-ink display: Part 2
            <small>01 Nov 2025</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/weather-station/weather_station_part1/">
            Weather and air quality station based on Raspberry Pi Pico2W and E-ink display: Part 1
            <small>01 Nov 2025</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/kiwifruit/">
            Kiwifruit
            <small>22 Aug 2018</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

  </body>
</html>
