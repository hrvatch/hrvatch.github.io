<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Search Results | Critical Path</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Search Results" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A personal blog that contains stuff of interest to Hrvoje Butina. Deep dives into ASIC design &amp; verification. And some shallow dives into the embedded and low-level development." />
<meta property="og:description" content="A personal blog that contains stuff of interest to Hrvoje Butina. Deep dives into ASIC design &amp; verification. And some shallow dives into the embedded and low-level development." />
<link rel="canonical" href="https://criticalpath.dev/search/" />
<meta property="og:url" content="https://criticalpath.dev/search/" />
<meta property="og:site_name" content="Critical Path" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Search Results" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"A personal blog that contains stuff of interest to Hrvoje Butina. Deep dives into ASIC design &amp; verification. And some shallow dives into the embedded and low-level development.","headline":"Search Results","url":"https://criticalpath.dev/search/"}</script>
<!-- End Jekyll SEO tag -->
<!-- CRITICAL: Apply theme immediately to prevent flash -->
  <script>
    (function() {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme) {
        // User has manually set a preference
        document.documentElement.setAttribute('data-theme', savedTheme);
      } else {
        // Follow system preference
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        document.documentElement.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
      }
    })();
  </script>
  <link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css">

  
  
  <link type="application/atom+xml" rel="alternate" href="https://criticalpath.dev/feed.xml" title="Critical Path" />
</head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Critical Path</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/projects/">Projects</a>
  <a class="nav-item" href="/posts/">Posts</a>
  <a class="nav-item" href="/tags/">Tags</a>
  <a class="nav-item" href="/about/">About</a>
  <a class="page-link theme-toggle" href="#" aria-label="Toggle theme" id="theme-toggle">
    <i class="fas fa-circle-half-stroke"></i> <!-- Will switch between sun/moon -->
  </a>
  <a class="page-link search-toggle" href="#" aria-label="Search">
    <i class="fas fa-search"></i>
  </a>
  <!-- Search box (hidden by default) -->
  <div class="search-overlay" id="search-overlay">
    <div class="search-container">
      <button class="search-close" id="search-close" aria-label="Close search">
        <i class="fas fa-times"></i>
      </button>
      <div class="header-search">
  <h2>Search</h2>
  <form class="header-search-form" action="/search/" method="get">
    <input type="text" id="search-box" name="query" placeholder="Search posts..." autocomplete="off" autofocus>
    <button type="submit" aria-label="Search">
      <i class="fas fa-search"></i>
    </button>
  </form>
</div>

    </div>
  </div>
</div>

      </nav>
  </div>
  <div class="wrapper">
    <div class="site-header-about-text">
      A blog about topics that interest Hrvoje Butina.
    </div>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Search Results</h1>
  </header>

  <div class="post-content">
    <div class="posts-archive">
  <div class="search-query-display">
    <p>Searching for: <strong id="search-query-text"></strong></p>
  </div>
  
  <div id="search-results-info"></div>
  <ul class="year-list" id="search-results"></ul>
</div>

<script>
  window.store = {
    
      "picorv32-soc-development-of-a-picorv32-based-soc-part1": {
        "title": "Building a custom RISC-V based SoC on FPGA - Part 1",
        "author": "",
        "category": "",
        "content": "Recently I got an idea to create my own System-on-Chip (SoC). The main purpose of this SoC is tovalidate a small IP in a real system: plugging it into the SoC, synthesizing it for an FPGA, writinga driver for it, and validating it in a real environment. As my motivation for doing a write-up onthis project, maybe this design (and this post) will motivate someone to undertake a similarproject.My initial goal was to build an SoC similar to what is presented in this paper: The simply-V Framework: an Extensible RISC-V Reconfigurable Soft-SoC for Open Research and Fast Prototyping. I quickly found out a couple of things:  I’m not that familiar with RISC-V ISA.  I’m not familiar with the RISC-V ecosystem. What do I mean by that? In the paper mentioned aboveauthors are using RISC-V Debug Module, PLIC, etc. I’m not familiar with those components, it will take me some time to become familiar with all of them.  The main reason - I’m a bit rusty from not doing digital design for a couple of years now (my primary focus was ASIC verification) and I wanted to build as much of the designmyself to ‘lube’ my digital design skills.  I don’t know enough about embedded Linux development.To summarize: the scope of the paper is too big for me at the moment.My ultimate goal is to do the SoC capable of booting Linux but at the moment I’ll need a couple ofsimpler stepping stones before I reach that goal.The first of many such steps is the PicoRV32 based SoC.Choice of hardware and EDA toolsThrough the years I’ve procured a couple of FPGA development boards - either at a low cost, orthrough my work in the Faculty of Electrical Engineering and Computing. I have thefollowing boards at my disposal:  Digilent Zedboard - aZynq-7000 Development board. I bought this board while I was still a student, got itwith academic discount. Paid something like ~200€ at the time for it. I’ve used this one a lot. Couple of years ago I’ve built a software defined radio (SDR) based on Analog Devices AD9364 (FMC expansion card) and ZedBoard as a carrier board.  Avnet ULTRA96-G REV 1 - it’s an older board which got an update over the years. I’ve got this one dirt cheap, I think something like 50$ and I’ve never used it which is a complete shame. I see now there are newer versions of this board, but the old one is still good.  Digilent Nexys Video -I’ve seen this board sitting in the University storage room, and since no-one was using it ata time I was able to borrow it, under the promise I’d develop something on it, some stuffthat could be of use to the students. Well, now I have the chance to keep my promise!I’ve settled on using the Nexys Video dev board. It’s feature rich, has enough resources toimplement a decently large design, and most importantly I can use free Vivado license to synthesizethe design for this board. It’s a perfect board to implement design of the size (and speed) I’maiming at.As for the software and simulators, initially I thought of using a complete free and open sourcesolutions. I was thinking of using Altair DSim since it’s free forpersonal use, but I never got it to work with a free license. The simulator that is integratedinside a Vivado also got a boost over the years. I tried playing with it, and I’m not a big fan. TheVivado interface is clunky and I got glitches when running it on my machine - BTW I use ArchLinux.For now I think I’ll still use commercial EDA tools. Through the university I have access to Cadencetoolchain, namely to the Xcelium and JasperGold Formal tools. Since I’m not building anythingcommercial (everything I build and post on this blog is either going to be published in some kind ofpaper or it’s built for research purposes) I’ve decided to use the commercial tools for now; butI’ll most definitely switch to free/open source solutions sometime in the future.Eventually, I want to check out Verilator and theSymbiYosys is of a particular interest to me.ArchitectureBefore I start with the SoC I have to make a couple of architectural choices. The first and the mostimportant is the type of bus I’m going to use to connect everything. Since I have a fair amount ofexperience with the AXI bus, I’ve decided to use it. The design I’m going to make is not a bigdesign and I don’t need some advanced AXI features, therefore I’ve settled on an AXI4-Lite bus.There is one more reason why I chose AXI bus - the availability of the interconnect. InitiallyI wanted to use Xilinx interconnect (since I’m developing for a Xilinx FPGA), but I decided to usethe least amount possible of Xilinx components. There is no particular strong reason why I did it. Ikinda dislike the block diagram approach and working in GUIs in general, if I use Xilinx IPs I’llmost definitely be backed into this corner at some point. To be fair, the Vivado block diagram flow isquick if you’re using Xilinx components, but if you’re not (and you’re not in the business ofbuilding your own IP suitable for Vivado use), then it becomes a big inconvenience.If I had to name one good reason, it would be to reuse this design on an FPGAs of other vendorsbesides the Xilinx.ETH Zürich provides a huge number of well designed and tapeout verified components and IPs throughthe PULP platform. I’ve decided to use AXI4-Lite interconnect from the PULP platform Githubrepository. Repository also includes asmall testbench and an example on how to instantiate and use this interconnect.        About PULP PlatformThe PULP Platform is an open-source, energy-efficient computing architecture developed by ETH Zürich and the University of Bologna since 2013. I won’t list all the aims of the project,you can check that out here. To me, personally,the most interesting thing is the open-source availability of the verified hardware components.And the list of components - to say the least - is impressive. Check their Github pagefor more details.And I also need to mention this - one of the coolest things I’ve seen in the repository is the SoCdeveloped and taped out in an Open-Source EDA flow. I recommend readers to check this out: 34 mm2 End-to-End Open-Source 64-bit Linux-Capable RISC-V SoC in 130nm BiCMOS.  The next choice I’ve had to make is which RISC-V core to use. I had a few requirements:  Simple to use and integrate  Good documentation  Support for RISC-V IMC instruction set. Why M and C? It’s quite possible that I’ll usemultiplication in the software that I develop. As for the C instruction set, I don’t want to useDRAM or store my program on an SD Card. Everything should fit inside a small SRAM  Must be either formally verified or verified in a constrained random manner against a Spike (orsome other) model  I should be able to connect the core to the AXI4-Lite interconnect via some kind of bridge, orideally there should be a built in solution to do this  The RISC-V core should be able to handle simple interruptsThe PicoRV32 RISC-V core satisfies all of the above. It’s a neat small RISC-V core, with good documentation and it’s very simple to integrate. Actually it’s so good,that if I was to use a simple RISC-V core in a project I was going to tapeout, this would be mychoice.As far as the rest of the components, I need a timer capability, capability to use switches, LEDs andbuttons (some kind of simple GPIO), most definitely UART for communication and debugging and I alsoneed SRAM to store the bootloader and the program being ran.I’ve decided to build all of those componentsmyself.The final architecture should look something like this:                    PicoRV32 based SoC block diagramAh and I forgot, I want everything to work on at least 100 MHz.Development of AXI4-Lite SRAM moduleThis module is used to access static RAM via AXI4-Lite interface. This is where my programs and thebootloader will be stored. I had a couple of requirements for this module:  Module should support back-to-back accesses on each clock cycle via AXI4-Lite interface.  The block should be parametrizable with the SRAM bit width and the SRAM depth.  The block should support byte access.I won’t go into much detail how I’ve designed this. Sufficient to say, there are enough resources ondesigning your own AXI4-Slave. The most useful resource I’ve found on the internet was on the ZipCPUblog: Building the perfect AXI4 slave.The most challenging thing I’ve had to deal with was throughput and the long backpressure pathfrom the slave’s AxREADY/xREADY signals. For example, the ARREADY goes from theAXI4-Lite SRAM module to the interconnect, interconnect ARREADY goes to the PicoRV32. This long combinatorial path resulted in not being able to close the timing for thedesign. I’ve dealt with these issues of throughput and long combinatorial path by using so called Skid buffers.I’ve used the idea from this article Building a Skid Buffer for AXIprocessing. Although the idea is fairly simple, I was actually surprised how much troubleI’ve had implementing it. The good thing is I’ve had a formal testbench ready to verify correctness ofthe AXI4-Lite protocol, and that made development of the AXI4-Lite interface a lot easier.I encourage the reader to go through the ZipCPU blog post, the concept of Skid buffers (orregister slices) is very important in digital design.I’ve synthesized this module in Vivado and found out one interesting thing. Vivado infersBlock RAM to be used for the SRAM. On my device (Artix 7 XC7A200T, Speed grade -1), BRAM shouldtheoretically work at max frequency of ~450 MHz. But when I checked the timing report after synthesis,I found out the theoretical maximum frequency was roughly 200 MHz. The Xilinx UG473, AdditionalBlock RAM Features in 7 SeriesDevices states that if you want toachieve max frequency, an additional register must be placed on the output, therefore I did that.This increases latency by 1 extra clock cycle, on top of 1 clock cycle of latency BRAM already has,but it increased the theoretical maximum frequency to roughly 350 MHz.                          AXI4-Lite Consecutive reads from the AXI4-Lite slave. The slave supports maximum read throughput. A 3 clock cycles of latency can be seen from read request to read response.                          Consecutive writes to the AXI4-Lite slave. Slave supports maximum write throughput.The AXI4-Lite protocol was verified in JasperGold FPV. The data integrity was verified by usingformal scoreboarding techniques. Decent explanation of Formal Scoreboarding can be found here (note:it requires registration): Formal 101: Exhaustive Scoreboarding and Data IntegrityVerification Made Easy.I would be interested to see if I could do the entire verification in SymbiYosys.More details about the AXI4-SRAM module and the module sources are available in the following Github repositoryAXI4-Lite Scratchpad.Development of AXI4-Lite Counter/TimerFor the timers, I wanted something simple. I came up with the following design:                    IRQ will be triggered every ((1+PRESCALER VALUE)/Fclk)*(THRESHOLD VALUE) seconds; Fclk = clockfrequency in HzAlthough this is a counter, technically it’s a timer, because it counts clock cycles. The counterintegrates 32-bit prescaler that first divides the input frequency. I could’ve used less than32-bits, but since the bus is 32-bits wide, and since I have enough resources on my dev board, I’vesettled on a 32-bit prescaler.The counter supports setting compare (threshold) value. Each time a threshold value is reached,a threshold sticky bit is set. The threshold bit is also connected to the interrupt line, thereforewhen the counter reaches the threshold value an interrupt is asserted. Reading from the status registerclears this threshold sticky bit.For the AXI4-Lite interface part, I’ve used what I’ve already written and debugged for SRAM, simplycleaned it up a bit.The design and a small driver are located in the AXI4-Lite Timerrepository.Development of AXI4-Lite UARTFor the UART, I’ve initially wanted to build a 16550 compatible UART block. In the end I’ve decidednot to do that. There is only one major reason: I’ll be using only the UART TX/RX lines, don’t carefor the flow control. But I’ll be using some of the good features of the 16550 UART.I decided on the following features:  Default should be 115200 baud, 8 data bits, 1 stop bit, no parity, should work out of the box.  I want it to support baud rates up to (and including) 921600 bits per second.  I want it to be on-the-fly configurable.  It shouldn’t be a burden on the CPU, it needs to use TX/RX FIFOs and it needs to supportinterrupts.  I need FIFO full/empty signals in the status registers, but also I want to have configurablethreshold.First, the AXI4-Lite part. I’ve decided to reuse what I’ve had before i.e. AXI4-Lite interface withdebugged handshaking, and I’ve added a couple more registers. For the FIFOs, I settled on the 16-deepFIFOs. In case a FIFO depth of 16 bytes proves to be too small, I can increase it in the future, butfor now I think the size is good enough.The weakest point of the AXI4-Lite UART is the simplicity of the testbench. I’m only verifyingfeatures in a direct test manner. In the ideal universe I would’ve done a fair bit of constrainedrandom/metric driven verification, and should’ve built a UVM testbench, but I was too excited to seethe design in action as soon as possible. Since this is not a commercial design but my own hobbyproject, I’ve settled on a simple testbench and validation on an FPGA board.The design and a small driver are located in the AXI4-LiteUART.        Edit from the futureThis design has been synthesized and tested on an FPGA development board. I’vetested communication between the board and my PC with all the supported baud rates, 7 and 8 databits, all parity values and all options of the stop bits and it works well.If I get the chance to mentor students again in the future, the verification incompleteness of theAXI4-Lite UART could be used as a strength. I could give this to a student working on his/herbachelor thesis to learn the UVM and verify this design.  Development of a GPIOThe goal for the future is to build a fully working GPIO, but for now I’ll settle only on handlingLEDs. The fully capable GPIO module will have to wait a bit. The reason why I build this ‘LEDhandler’ is I wanted to have some kind of built-in debugging feature once I start validating mydesign on the board.In the end, I’ve settled on a single AXI4-Lite accessible register, which is connected to the LEDs.Verified in Formal, worked well. This design can be foundhere.Common clock and reset (CCR) moduleThe purpose of the CCR module is to handle everything related to the clock and reset capability ofthe SoC. The CCR module is a wrapper around the vendor PLL (in this case it’s Xilinx MMCM) and thelogic required to use the dedicated pushbutton on the development board as a reset button. A blockdiagram of the CCR module is shown in the figure below.                    Block diagram of a Common Clock and Reset module.I want the entire design to be under reset until the PLL locks, or if the user pushes a ‘Reset’button. Since the design is small enough, the CCR module is good as-is. If it grows too large,I have a strong suspicion I would run into clock/reset fanout issues. This is something tokeep in mind for the future.If someone wants to reuse this entire design on a different vendor FPGA, I think only this moduleneeds to be updated.IntegrationThe next thing I need to decide on is the memory map. I’ve decided to use 16-bit wide addresses (noneed for 32-bits, and this reduces the size of address decoder), and decided on the following memorymap:            Address Range      Size      Peripheral      Description                  0x1000 - 0x1FFF      4KB      Timer/Counter      Programmable timer with IRQ              0x2000 - 0x2FFF      4KB      GPIO (LEDs)      LED control interface              0x3000 - 0x3FFF      4KB      UART      Serial communication              0x4000 - 0x7FFF      16KB      SRAM      Main program memory              0x8000 - 0x8FFF      4KB      Bootloader ROM      UART bootloader      The PicoRV32 is issuing 32-bit addresses, but I’m truncating this in the PicoRV32 to AXI4-Liteinterconnect connection, by connecting only the 16 LSBs.The component connection was fairly simple. I’ve used the following configuration for the AXI4-Liteinterconnect:parameter axi_pkg::xbar_cfg_t AXI_XBAR_CFG_p = '{  NoSlvPorts:   AXI_MASTER_NBR_p,  NoMstPorts:   AXI_SLAVE_NBR_p,   MaxMstTrans:  2,  MaxSlvTrans:  2,  FallThrough:  1'b0,  LatencyMode:  axi_pkg::CUT_ALL_AX,  AxiAddrWidth: AXI_ADDR_BW_p,  AxiDataWidth: AXI_DATA_BW_p,  NoAddrRules:  AXI_SLAVE_NBR_p,  default: '0};I must admit I don’t fully understand the MaxMstTrans and MaxSlvTrans parameters. My assumptionis those control the number of outstanding transactions, i.e. the MaxMstTrans controls the numberof maximum outstanding transactions coming from the Master (PicoRV32), and MaxSlvTrans probablycontrols the number of outstanding transactions a slave can handle.Since the AXI4-Lite slaves I’ve built can accept two outstanding transactions, one currently handledand one waiting because of the skid buffer, this is the number I chose i.e. MaxSlvTrans = 2. Forthe master side I’ve chosen MaxMstTrans = 2 also. But again, since PicoRV32 doesn’t pipelinememory requests (it waits for the response before issuing the next) I think this shouldn’t matter atall.I’ve verified if the design works correctly for the values of MaxMstTrans and MaxSlvTrans I’veused and I didn’t see any issues at all.For the LatencyMode I’ve chosen axi_pkg::CUT_ALL_AX. This is recommended latency mode in thePULP documentation. Essentially, what this option does is it further breaks the combinatorial path ofthe AxREADY/xREADY signals.The address width is chosen to be the smallest possible, my intuition tells me this affects the widthof the address decoder and therefore potential maximum frequency as a consequence.As for PicoRV32, the documentation on their Github is excellent. I’ve created a package with all therelevant parameters used in the instantiation.  parameter bit ENABLE_COUNTERS_p = 1;  parameter bit ENABLE_COUNTERS64_p = 1;           parameter bit ENABLE_REGS_16_31_p = 1;  parameter bit ENABLE_REGS_DUALPORT_p = 1;  parameter bit TWO_STAGE_SHIFT_p = 1;  parameter bit BARREL_SHIFTER_p = 1;  parameter bit TWO_CYCLE_COMPARE_p = 0;  parameter bit TWO_CYCLE_ALU_p = 0;  parameter bit COMPRESSED_ISA_p = 1;  parameter bit CATCH_MISALIGN_p = 1;  parameter bit CATCH_ILLINSN_p = 1;  parameter bit ENABLE_PCPI_p = 0;  parameter bit ENABLE_MUL_p = 0;  parameter bit ENABLE_FAST_MUL_p = 1;  parameter bit ENABLE_DIV_p = 1;  parameter bit ENABLE_IRQ_p = 1;  parameter bit ENABLE_IRQ_QREGS_p = 1;  parameter bit ENABLE_IRQ_TIMER_p = 1;  parameter bit ENABLE_TRACE_p = 0;  parameter bit REGS_INIT_ZERO_p = 0;  parameter bit [31:0] MASKED_IRQ_p = 32'h 0000_0000;  parameter bit [31:0] LATCHED_IRQ_p = 32'h ffff_fff3;  parameter bit [31:0] PROGADDR_RESET_p = 32'h 0000_8000;  parameter bit [31:0] PROGADDR_IRQ_p = 32'h 0000_4010;  parameter bit [31:0] STACKADDR_p = 32'h ffff_ffff;The PicoRV32 was configured to start executing from the address 0x8000 (Bootloader). I’ve connectedTimer IRQ to the PicoRV32 IRQ[2] and UART to the PicoRV32 IRQ[3]. The reason why I didn’t use theIRQ[0] and IRQ[1] for Timer and UART is the PicoRV32 documentation states the ecall and ebreakinstructions (exceptions) will trigger an interrupt on IRQ[0] and IRQ[1] respectively.I’ve enabled internal counters, might come in handy if I ever have to do some performance profiling.I’ve enabled barrel shifter, multiply and division. No need for trace.I’ve used SRAM (Scratchpad) that I’ve developed for both the Bootloader ROM and for the SRAM. Forthe Bootloader, I’ve left the AXI4-Write signals unconnected.The PicoRV32 design files include PicoRV32-to-AXI4-Lite bridge and the PicoRV32 variant thatnatively uses AXI4-Lite interface. I’m using the latter version, therefore I don’t need toinstantiate/build any bridges, it’s easy to integrate and it works out of the box.Top-level simulationOn the top level I wanted to check if the components are connected correctly, and whether they workafter being integrated in a larger design. I want to do something simple, no major automated checks,I want to be able to confirm components work correctly after integration by checking the waveforms.I’ve decided to do some firmware-assisted verification i.e., I’ll build a simple bootloader anda hello_world program that will use LEDs and UART, compile them, and load them in the simulation intothe Bootloader/SRAM. There are two reasons why I want to do it this way:  I can check the waveforms and the internals of the design in the simulation. Since I don’t have ahuge multi-million gate design, simulation will be very quick and I can easily debug both thehardware and the software in the simulation.  I’ll be able to reuse most of the firmware when I validate design on an FPGA development board.The compilation/build process should produce the following artefacts:  A compiled and linked binary stripped of all unnecessary debug symbols and sections. This file willbe used once the design is deployed on an FPGA board. The bootloader will load this binary via theUART and execute the program.  A .lst file that will contain the RISC-V assembly. I can use this file to verify that thecompilation is successful and that generated ASM is okay,  A file containing hexadecimal representation of a stripped binary file. This file will be loadedin the simulator.        VLSI tipsEase of debugging and component/code reuse are some of the most important concepts in digital design anddigital verification  Building RV32IMC GNU ToolchainTo be able to do that I need a GNU toolchain that can be run on a Linux x86-64 host, and I’mtargeting (duh) PicoRV32 - in my case, that is RV32IMC. I’m certain there is a prebuilt GNU toolchainsomewhere in the outskirts of the Interwebz, I haven’t been able to find what I need, thus I decidedto build the GNU toolchain from the sources.Since I’m using Arch, these are the steps that work for me:# Install dependenciessudo pacman -S base-devel git python cmake ninja gawk \\    libmpc mpfr gmp zlib expat glib2# Clone the repositorygit clone https://github.com/riscv/riscv-gnu-toolchain.gitcd riscv-gnu-toolchain# Configure for bare-metal RV32IMC# --prefix: installation directory# --with-arch: target architecture# --with-abi: application binary interface (ilp32 = int/long/pointer are 32-bit)./configure --prefix=$HOME/riscv \\            --with-arch=rv32imc \\            --with-abi=ilp32# Build the bare-metal toolchain (newlib-based)# This builds: gcc, binutils, newlib, gdb# Takes roughly one hour sudo make -j$(nproc)# Add the installation directory to the PATH environment variableexport PATH=$HOME/riscv/bin:$PATH# Check versionriscv32-unknown-elf-gcc --version# Test compilecat &gt; test.c &lt;&lt; 'EOF'int main(void) {    volatile int x = 42;    return x;}EOFriscv32-unknown-elf-gcc -march=rv32imc -mabi=ilp32 -nostdlib -o test.elf test.cfile test.elf# Should show: ELF 32-bit LSB executable, UCB RISC-VTypical bare-metal compile flags that I use when building the code:CFLAGS = -march=rv32imc \\         -mabi=ilp32 \\         -nostdlib \\         -nostartfiles \\         -ffreestanding \\         -O2 \\         -WallIf required, the detailed instructions can be found here.        On the GNU Toolchain build stepsI’m aware the instructions on how to build GNU Toolchain for the RV32IMC target are availableonline, or in the 21st century you can ask LLM for the steps. The problem with the LLM/StackOverflow/Something else instructions is I’ve not been able to successfully reproduce them withoutissues every time. The main reason why I’ve written down these instructions is so I don’t have torepeat the entire research/debugging process again, I just want to be able to execute andeasily get the known results. To summarize, I’m mostly doing this for my own sake :-)  Generating compilation artefactsAs mentioned previously, we want to produce three targets as a result of compilation.  A compiled and linked binary stripped of all unnecessary debug symbols and sections  A .lst file that will contain the RISC-V assembly.  A file containing hexadecimal representation of a stripped binary file.To create a binary file with sections and relocation information discarded, an objcopy GNU utilitycan be used:objcopy -O binary firmware.elf firmware.binTo view executable in an assembly form, an objdump utility can be used:objdump -d -S firmware.elf &gt; firmware.lstThe last thing remaining is to generate a hexadecimal representation of the binary file created withthe objcopy command. For this purpose I’ve written a small Python script:#!/usr/bin/env python3import syswith open(sys.argv[1], \"rb\") as f:    bindata = f.read()# Pad to 4-byte boundarywhile len(bindata) % 4 != 0:    bindata += b'\\x00'for i in range(0, len(bindata), 4):    w = bindata[i:i+4]    print(\"%02x%02x%02x%02x\" % (w[3], w[2], w[1], w[0]))This script writes 32 bits of data in hexadecimal format into each line of the file. The output is inthe little-endian format. If a binary file is not 4-byte aligned, it’s first padded with zeros to a4-byte boundary.Bootloader, startup.S and hello_world program for the top-level simulationThe bootloader for the simulation is very simple. It contains only one instruction - jump to the first address in theSRAM.As for the startup files and the hello_world program itself, I won’t go into much detail. Code isworth more than a million words, and the code is available in the rv32-shock Github repository.        Project nameI figured I have to give this project a name and I’ve settled on calling it rv32-shock. The etymology of the name is from Croatian word “Šok” (a play on the acronym SoC), which directlytranslates into ‘shock’ in English. Since it’s RV32 based SoC, I figured ‘rv32-shock’ is a goodenough name.  startup.S is a program written in RISC-V assembly. This file is usually known as crt0.S in theembedded world. I didn’t write this file from scratch, but instead I reused the file from PicoRV32firmware and modified it for my ownpurpose.The file contains initialization of the registers, initialization of the stack pointer, interrupthandling routine and subfunctions that can be used to enable/disable interrupts. The interrupthandling routine performs the following:  Saves the context,  Executes the interrupt function,  Restores the context,  Continues main program execution.The main.c does the following:  Initializes UART  Programs the timer to interrupt every 1 second  Enables interrupt for the timerEvery time interrupt is triggered, a CPU will start running an interrupt routine. The interruptprogram will check if the cause of interrupt was indeed a timer. If it was, it will turn offthe currently lit LED, and it will turn on the LED next to it. After 50 seconds, CPU will executean ebreak instruction thus asserting a trap signal of the PicoRV32 CPU.        Handling simulation timeWaiting for 1 second in the simulation can take an eternity. On a complex, multi-million gate SoC,an actual second could take a couple of days of simulation time. Although this is not the case forthis design, it’s still prudent to reduce the simulation time to be as low as possible. In thesimulation, timer is not programmed to count every 1 second, but instead to ~500 clockcycles. This is good enough to validate the design and it reduces simulation time.  The startup.S and main.c form the basis for the hello_world.Drivers for handling timer/counter and UART are copied from their own respective repositories.The final thing needed is the linker script. At first I tried writing linker script myself. Theproblem with this approach is I write linker script once-a-year, and every time I have to rememberhow this is done all over again. There are numerous tutorials and documents online on how to do it.For example, previously I would refresh my memory by watching this YouTube series from the FastbitEmbedded Brain Academy. Since I needed a simple linkerscript and I wanted something done fast, this time I’ve asked the LLM for help. I’m amazed I got thelinker script that worked fully on the first go, without the need for any additional debugging.To make my life easier, I’ve created a Makefile that automates artefact generation. This Makefilecan be found in the sw/hello_world subdirectory in the rv32-shock Github repository.Loading program into the RAM in the simulationAfter building the hello_world program a .hex file is produced. This file is used to initializeRAM in the simulation. My simulation Makefile has the possibility to take bootloader and SRAMinitialization files as parameters. If a file is provided, there is an argument in the Makefile thatis passed to the simulator, to create a define.There are multiple ways to achieve this depending on the language used and preferences; I’ve settledon using the $readmemh Verilog system task. The following code is a direct copy-paste from the toplevel testbench.`ifdef BOOTLOADER_INIT_FILEinitial begin  static int fd = $fopen(`BOOTLOADER_INIT_FILE, \"r\");  if (!fd) begin    $display(\"Memory file %0s not found!\", `BOOTLOADER_INIT_FILE);    $fatal;  end  $fclose(fd);  $readmemh(`BOOTLOADER_INIT_FILE,     picorv32_soc_dut.axi_lite_bootloader_inst.ram_block);end`endif`ifdef RAM_INIT_FILEinitial begin  static int fd;  fd = $fopen(`RAM_INIT_FILE, \"r\");  if (!fd) begin    $display(\"Memory file %0s not found!\", `RAM_INIT_FILE);    $fatal;  end  $fclose(fd);  $readmemh(`RAM_INIT_FILE,     picorv32_soc_dut.axi_lite_scratchpad_inst.ram_block);end`endif // RAM_INIT_FILETop level testbenchThe top level testbench contains the DUT instantiation, blocks used for generating clock and reset,block of code that prints bytes received from UART and another block of code used to print the LEDstatus. After running simulation I’m getting the following output:LED status: 00000000LED status: 00000001@             86232000: RX = 0x55 ('U')LED status: 00000010@             97152000: RX = 0x41 ('A')LED status: 00000100@            108052000: RX = 0x52 ('R')LED status: 00001000@            118952000: RX = 0x54 ('T')...LED status: 00010000LED status: 00000100LED status: 00001000LED status: 00010000LED status: 00100000LED status: 01000000LED status: 10000000And the waveforms display the following…                          rv32-shock waveforms showing UART and LED activityI will consider this a “good enough” design and proceed with backend work: writing constraints,synthesis, timing closure, place and route, bitstream generation, aaaand I still have to write abootloader!All of that (and more) will be written up in the next Part 2 of the project.SummaryIn this first part of this series I’ve covered the architectural choices, design and verification ofthe individual components, and integration of the PicoRV32 based SoC. The SoC includes a PicoRV32RISC-V core connected via the PULP AXI4-Lite interconnect to an SRAM, a timer/counter, a UART, asimple LED controller, and a bootloader ROM. All components were designed with back-to-backthroughput in mind, using skid buffers to break long combinatorial paths. The AXI4-Lite protocol anddata integrity were verified formally in JasperGold, and the integrated design was validated insimulation using firmware-assisted verification.In Part 2 I’ll cover the backend work: writing Vivado constraints and TCL scripts, synthesis, timinganalysis and closure, place and route, and bitstream generation. I’ll also go through thedevelopment of the UART bootloader, reuse of the hello_world program, and validation on the NexysVideo FPGA board — including resource utilization numbers, achieved maximum frequency, and a videoshowing the whole thing in action.",
        "url": "/picorv32_soc/development-of-a-picorv32-based-soc-part1/",
        "date": "2026-01-31"
      }
      ,
    
      "productivity-using-notion-to-set-things-in-motion": {
        "title": "Using Notion to set things in motion",
        "author": "",
        "category": "",
        "content": "Ultimately, I decided I want to manage my hobby projects in a Scrum style.I can see people screaming: “Are you insane? What drugs are you on? Why do you want to turn your fun activity into something that feels like some annoying and life-draining corporate project?” First of all, I don’t think the Scrum itself is stupid and life draining, it’s the 1000 other things like managers emphasizing and prioritizing writing Jira tickets and doing time estimates while you’re trying to deliver that bug fix on the Friday afternoon. This is not it. Here, you’re your own manager, and Scrum is just a way of keeping track of things. Besides there are numerous benefits, but the most important ones to me:  I want to keep track of my projects,  I want to keep myself accountable, and actually finish my projects.There are some additional benefits that are not obvious at first. Thinking about how to decompose your project into achievable tasks forces you to ACTUALLY think hard about what you’re trying to do, it forces you to do a deep analysis. Once you break it down, you’ll have clear steps on how you’re going to achieve something, and you’ll also have some insight when and how you’re going to complete your project.Of course, I don’t think this is feasible for every little thing I do. I quickly found out it’s better to start immediately working on my idea, create something concrete, gather more information and to get a feeling is this something I’d really like to do or this was some passing whim. After I’m sure I find it fun (or useful), I’ll do some “project planning”.        Setting SMART goalsCouple of months ago my girlfriend (who is very smart) taught me about setting SMART goals. I keep forgetting what the acronym stands for, but I vividly remember when she first told me about it, it resonated with me. Well, instead of asking her for the 100th time what each letter means, I’ll now write it down:  S - Specific: Clearly define what you want to achieve, including details like who, what, where and why. (e.g., “I’ll build a RISC-V core”, becomes “I’ll build a basic, single cycle, 32-bit RISC-V core supporting IMAC instruction set to improve my digital design skills, and to become familiar with the RISC-V ecosystem”.  M - Measurable: Include criteria to track progress and know when you’ve succeeded, using numbers, percentages, or other data points.  A - Achievable: Ensure the goal is challenging but realistic, with resources and capabilities to reach it.  R - Relevant: Confirm the goal matters to your broader objectives and is worthwhile.  T - Time-bound: Set a specific deadline or time frame for completion, creating urgency and focus.  Task breakdownThe next thing I decided on is the Project and Task breakdown. I decided on the following:  I want to have the following hierarchy: Projects-&gt;Epics-&gt;Stories-&gt;Tasks.  Each project can have multiple Epics. Each Epic describes a significant feature that I need to develop or some area that I need to study that would take multiple months.  Epics are further decomposed into Stories. Each Story contains a meaningful unit of work that can be done in a month or so.  Stories are decomposed into tasks. Each task would represent a concrete action needed to complete a Story.Here is one hypothetical project example that for the hierarchy I’ve described above. Let’s say I want to design a floating-point unit. This would be my Project. Now, there are multiple ways how I would decompose this Project into Epics, but let’s say my approach is the following:  Floating point unit documentation,  Floating point unit design,  Floating point unit validation on a Field Programmable Gate Array (FPGA).  etc.The 2nd Epic - Floating point unit design - I would further decompose into the following Stories:  Multiplication (F.MUL),  Leading Zero Counter (LZC),  Division (F.DIV),  Square root (F.SQRT),  etc.The F.MUL story can be decomposed into the following tasks:  Implement mantissa multiplication,  Implement normalization,  Implement exponent calculation,  Implement rounding,  Create a Formal verification environment,  Get a Formal proof of the F.MUL datapath,  etc.And here is a visualization of the above:flowchart LRA(Floating point unit)A --&gt; E1(Epic: FPU documentation)A --&gt; E2(Epic: FPU design)A --&gt; E3(Epic: FPU implementation on an FPGA)subgraph FPU documentationE1 --&gt; E1S1(...)endsubgraph FPU implementation on an FPGAE3 --&gt; E3S1(...)endsubgraph \"FPU Design\"E2 --&gt; E2S1(Story: Multiplication F.MUL)E2 --&gt; E2S2(Story: Leading Zero Counter LZC)E2 --&gt; E2S3(Story: Division F.DIV)E2 --&gt; E2S4(Story: Square root F.SQRT)E2S2 --&gt; E2S2T1(...)E2S3 --&gt; E2S3T1(...)E2S4 --&gt; E2S4T1(...)subgraph F.MULE2S1 --&gt; E2S1T1(Task: Implement mantissa multiplication)E2S1 --&gt; E2S1T2(Task: Implement normalization)E2S1 --&gt; E2S1T3(Task: Implement exponent calculation)E2S1 --&gt; E2S1T4(Task: Implement rounding)E2S1 --&gt; E2S1T5(Task: Create Formal verification environment)E2S1 --&gt; E2S1T6(Task: Get a Formal proof of the F.MUL datapath)endendChoosing tool for project and task planningWhen it came time to pick tool for project management I wanted a tool that supported the followingcriteria:  It must be free to use,  It must be a web based tool because I’m working on multiple machines and multiple operating systems,  It should have an establishaed reputation, i.e., there should be an existing user base, I don’twant the tool to be cancelled or disappear overnight,  It should support building a hierarchy of Projects-&gt;Epics-&gt;Stories-&gt;Tasks as I’ve outlined previously,  It should allow me to keep track of time for each Task,  It should be possible to have a board (Kanban style) where I could see the task breakdown for the current month (Sprint),  Once I set it it up, it should be easy to use - I should be able to plan tasks for the current month witha couple of clicks, adding Tasks, Stories, Epics and Projects should be simple.There are bajillion tools that fit these criteria; I’ve spent a couple of days trying some of those. Thereare two tools that I really liked: JetBrains YouTrackand Notion. In the end I chose Notion, not because one tool is betterthan the other, it was simply a coin toss choice, and Notion won.        Retrospective: Using NotionIn retrospective, Notion was actually not that easy to set-up. It took me roughly 3 days to set up everything. In these 3 days I’ve included research, watching tutorials and all the trial and error before I got what I actually wanted. It might be a  skill issue, but I think the main reason for the non-ease-of-use is it has a very rich featurset. It takes some time to get familiar with the required features, tool flow and the intended way or work.I’ll mention two resources that actually got me started:  Anthropic’s Claude AI - It helped a lot when I started using Notion. Btw I’m notendorsing Claude above any other currently available LLMs, I used it because I had the fullsubscription at the time.  The Notion Tutorial - Full Course for Beginners on YouTube.This video helped ALOT. It’s long (roughly 2 hours) but it’s worth watching if you’re seriousabout using Notion. The video author also has lots of other videos on topics surrounding Notionand productivity in general. Fully recommend.  Using Notion to set things in motionFirst I’ll start with the results, and then I’ll provide a step-by-step solution on how to implementthis yourself in Notion.The solution I’ve built focuses around four main databases: one database containing Projects,one database containing Epics, one database containing all Stories and one database containing all Tasks. Each project gets its own separate page.The Projects database lists all the projects with their status, description, start and end date.                          Notion database containing a list of Projects with the accompanying propertiesThe Epics database contains all Epics for all Projects. Each Epic is assigned to on or more Projects. Each Epic contains a list of Stories required to finish that particular Epic. The Estimated Hours, Actual Hours, Remaining Hours, and Progress are automatically calculated. Estimated and Actual Hours are sum of the same-named properties of all Stories contained inside an Epic.                          Database containing list of all Epics. Estimated hours and Actual hours are automatically calculated by summing those properties for all the Stories contained in an EpicThe Stories database contains all Stories for all Projects. Each Story is assigned to one (or more)Epics. Estimated Hours, Actual Hours, Remaining Hours and Progress are automatically calculated.Like in the Epics database, the Estimated Hours and the Actual Hours are are calculated by summingthe values of the same-names properties for all Tasks contained within a Story.                          Database containing list of all Stories. Estimated hours and Actual hours are automatically calculated by summing the same-named properties for all the Tasks contained inside a StoryThe Tasks database contains as list of Tasks for all Projects. Each Task is described with thefollowing properties:  Name of the task,  Task description,  Status (In progress, Ongoing, Done),  Estimated hours - time it takes to finish a task,  Actual Hours - time it took to finish a task,  Over-Under - automatically calculated property, describing if the task was over or under estimated,  Variance - time difference between the Estimated and Actual Hours. Also auto calculated.                          Tasks database on the Backlog view. The Backlog view is used to see all the tasks that are not being worked on this month.Tasks that are going to be worked on in the current month are displayed on a board. The Kanban boardstyle is, in my opinion, a great tool to visually depict work at various stages of a process.                          The Kanban board show which tasks are planned to be worked on this month, but are still not in progress, tasks I'm currently working on, and tasks I've finished this month.As I’ve mentioned before, each project gets a dedicated Project dashboard page. This page essentiallycontains a link to the Epics, Stories and Tasks databases, but it’s set up in such a way to providea clear overview of the Project.                          Project dashboard pae showing list of Epics, Stories an Tasks related to the Project. Tasks are show in the Kanban board style.Tasks in the Project dashboard are displayed in two different views: Kanban style, and as a list of Project relatedtasks currently in the backlog.                          List of tasks in the backlog for the selected Project.Steps to set up a Scrum-based project management system in NotionI’ve split the setup into the following steps:  Core database setup,  Create essential views,  Create project dashboard template,  Creating a project,  Sprint (month) planning and executionAfter you create a Notion account, you’ll be met with a default workspace. My suggestion is toremove the ‘New page’, ‘Welcome to Notion!’ and ‘To Do List’. Add everything under the ‘Private’section.Part 1: Core Database SetupStep 1: Create Projects Registry  Create a new page in Notion called “Project Management Hub”  Type /database and select “Database - Full page”  Name it “Projects”  Add properties:          Name (Title) - Project name      Status (Select) - Options: Planning, Active, On Hold, Completed      Description (Text) - Project description      Start Date (Date)      Target End Date (Date)      Step 2: Create Epics Database  On the Project Management Hub page, create another database  Type /database and select “Database - Full page”  Name it “Epics”  Add properties:          Name (Title) - Epic name      Projects (Relation) - Link to Projects Registry - Enable Two-way relation (Epics will appear in Projects database,and we’ll be able to use properties from the Epics database in Projects database)      Description (Text) - Epic description      Status (Formula) - From Stories (configure after Stories created)      Estimated Hours (Formula) - From Stories (configure after Stories database is created)      Actual Hours (Formula) - From Stories (configure after Stories created)              Notion: Rollup of rollupsThe Estimated Hours and Actual Hours should (in my opinion) be automatically calculated bysumming up values of same-named properties from all the Stories associated with a particular Epic. Unfortunately,Notion doesn’t support Rollups of Rollups, but fortunately there is a workaround for this. Wecan use formulas to calculate Estimated Hours and Actual Hours. I got this solution from thefollowing YouTube video: How to Create a Nested Rollup in Notion (rollup of a rollup) 2024 Tutorial with free template  Step 3: Create Stories Database  Create another database on the Project Management Hub page  Type /database and select “Database - Full page”  Name it “Stories”  Add properties:          Name (Title) - Story name      Projects (Relation) - Link to Projects database - Enable Two-way relation      Epic (Relation) - Link to Epics database - Enable Two-way relation      Description (Text) - Story description      Status (Formula) - From Tasks (configure after Tasks database is created)      Estimated Hours (Rollup) - Story time estimate (configure after Tasks created)      Actual Hours (Rollup) - From Tasks (configure after Tasks created)      Step 4: Create Tasks Database  Create another database on the Project Management Hub page  Type /database and select “Database - Full page”  Name it “Tasks”  Add properties:          Name (Title) - Task name      Project (Relation) - Link to Projects database - Enable Two-way relation      Story (Relation) - Link to Stories database - Enable Two-way relation      Epic (Rollup) - From Story -&gt; Epic. Configure: Relation: Story, Property: Epic, Show original      Description (Text) - Task description      Status (Status) - Options: Not started, In progress, Done      Month (Select) - Options: Backlog, January 2026, February 2026, March 2026, etc. Add yourown relevant months.      Estimated Hours (Number) - Time estimate      Actual Hours (Number) - Time logged      Step 5: Configure Rollup PropertiesIn Stories:  Click Actual Hours -&gt; Configure rollup  Relation: Tasks, Property: Actual Hours, Calculate: Sum  Click Estimated Hours -&gt; Configure rollup  Relation: Tasks, Property: Estimated Hours, Calculate: Sum  Click Status -&gt; Edit Property -&gt; Edit Formula. Formula:    length(prop(\"Tasks\").filter(current.prop(\"Month\").lower() == \"backlog\")) == length(prop(\"Tasks\").map(current.prop(\"Month\"))) ? \"Backlog\".style(\"red\", \"red_background\") : (length(prop(\"Tasks\").filter(current.prop(\"Status\").lower() == \"done\")) == length(prop(\"Tasks\").map(current.prop(\"Status\"))) ? \"Completed\".style(\"green\", \"green_background\") : \"In progress\".style(\"blue\", \"blue_background\"))        This will set the property automatically:          If all Tasks for the selected Story are in Backlog -&gt; Status = Backlog      If all Tasks for the selected property are Done -&gt; Status = Done      Otherwise -&gt; Status = In progress      In Epics:  Click Estimated Hours -&gt; Edit Property -&gt; Edit Formula  Formula:    sum(prop(\"Stories\").map(current.prop(\"Estimated Hours\")))        Click Actual Hours -&gt; Edit Property -&gt; Edit Formula    sum(prop(\"Stories\").map(current.prop(\"Actual Hours\")))        Click Status -&gt; Edit Property -&gt; Edit Formula. Formula:    length(prop(\"Stories\").filter(current.prop(\"Status\").lower() == \"backlog\")) == length(prop(\"Stories\").map(current.prop(\"Status\"))) ? \"Backlog\".style(\"red\", \"red_background\") : (length(prop(\"Stories\").filter(current.prop(\"Status\").lower() == \"completed\")) == length(prop(\"Stories\").map(current.prop(\"Status\"))) ? \"Completed\".style(\"green\", \"green_background\") : \"In progress\".style(\"blue\", \"blue_background\"))        This will set the property automatically:          If all Stories for the selected Epic are in Backlog -&gt; Status = Backlog      If all Stories for the selected property are Completed -&gt; Status = Completed      Otherwise -&gt; Status = In progress      Step 6: Add Calculated PropertiesIn Epics, add:  Remaining Hours (Formula):    prop(\"Estimated Hours\") - prop(\"Actual Hours\")        Progress % (Formula):    round(prop(\"Actual Hours\") / prop(\"Estimated Hours\") * 100)        Click Progress % -&gt; Edit property -&gt; Show as: BarIn Stories, add:  Remaining Hours (Formula):    prop(\"Estimated Hours\") - prop(\"Actual Hours\")        Progress % (Formula):    round(prop(\"Actual Hours\") / prop(\"Estimated Hours\") * 100)        Click Progress % -&gt; Edit property -&gt; Show as: BarIn Tasks, add:  Variance (Formula):    prop(\"Actual Hours\") - prop(\"Estimated Hours\")        Over/Under (Formula):    if(prop(\"Actual Hours\") &gt; prop(\"Estimated Hours\"), \"Over\".style(\"red\", \"background_red\"), if(prop(\"Actual Hours\") == 0, \"\", \"✓ Under\".style(\"green\", \"background_green\")))      Part 2: Create Essential ViewsViews for Epics  Full view (Table)          Rename view to: Full view      Group by: Projects        Default view (Table)          Show: Name, Projects, Status, Estimated Hours, Actual Hours, Progress %      Group by: Project        By Status (Board)          Group by: Status      Filter by Project as needed      Views for Stories  Full view (Table)          Rename view to: Full view      Group by Project      Sort by: Epic        Default view (Table)          Show: Name, Project, Epic, Status, Estimated Hours, Actual Hours, Progress %      Group by: Project      Sort by: Epic        By Epic (Table)          Group by: Epic      Show time tracking columns      Views for Tasks  Current Month (Board) - PRIMARY VIEW          Group by: Status      Filter: Month -&gt; Is -&gt; January 2026      Filter: Status -&gt; Is not -&gt; Backlog      Properties: Name, Project, Epic, Estimated Hours, Actual Hours      Sort: Project      This shows ALL current work across ALL projects!        All Backlogs (Table)          Filter: Month -&gt; Is -&gt; Backlog      Group by: Projects      Sort by: Projects, Story        By Project (Table)          Group by: Projects      Sort by: Status, Projects        Time Tracking (Table)          Show: Name, Projects, Epic, Story, Estimated Hours, Actual Hours, Variance, Over/Under      Group by: Projects      Part 3: Create Project Dashboard TemplateStep 1: Create Template Page  In Project Management Hub, create a new page: “PROJECT DASHBOARD TEMPLATE”  Add header:# [Project Name]⚠️ TEMPLATE - Duplicate for each new project**Summary**: [Project summary]Set 2: Add Linked Database - Projects  Type /linked database  Select “Projects”  Create new view: Project Name  Filter: Project -&gt; Name -&gt; [leave empty - will set per project]Step 3: Add Linked Database - Epics  Type /linked database  Select “Epics”  Create new view: “Project Epics”  Filter: Project -&gt; [leave empty - will set per project]  Show: Name, Status, Estimated Hours, Actual Hours, Remaining Hours, Progress %  Group by: StatusStep 4: Add Linked Database - Stories  Type /linked database  Select “Stories”  Create new view: “Project Stories”  Filter: Project -&gt; [leave empty]  Show: Name, Epic, Status, Estimated Hours, Actual Hours, Remaining Hours, Progress %  Group by: EpicStep 5: Add Linked Database - Current Sprint Tasks  Type /linked database  Select “Tasks”  Create new view: “Project Current Month”  View type: Board  Filters:          Project -&gt; [leave empty]      Month -&gt; Is -&gt; January 2026        Group by: Status  Show: Name, Epic, Estimated Hours, Actual HoursStep 6: Add Linked Database - Backlog  Type /linked database  Select “Tasks”  Create new view: “Project Backlog”  View type: Table  Filters:          Project -&gt; [leave empty]      Month -&gt; Is -&gt; Backlog        Sort by: Story  Group by: StoryTemplate is complete!Part 4: Create Your First ProjectLet’s create first project to demo the template.Step 1: Register the Project  Go to Projects Registry database  Click “New”  Fill in:          Name: RISC-V SoC      Status: Active      Description: Complete RISC-V System-on-Chip implementation      Start Date: [Your date]      Target End Date: [Your target date]      Step 2: Create Project Dashboard  Go to PROJECT DASHBOARD TEMPLATE  Click “…” menu → Duplicate  Rename to “RISC-V SoC Dashboard”  Update summary  Update all linked database filters:          In each view, edit filter: Project -&gt; Is -&gt; RISC-V SoC      Step 3: Create Epics  Go to Epics database  Create three entries:Epic 1:  Name: RISC-V Core  Project: RISC-V SoC  Description: Design and implementation of the RISC-V processor coreEpic 2:  Name: AXI Interconnect  Project: RISC-V SoC  Description: Implementation of AXI bus interconnect for system communicationEpic 3:  Name: AXI Slave Generator  Project: RISC-V SoC  Description: Tool for generating AXI slave peripheralsStep 4: Create Stories  Go to Stories database  Create two entries:Story 1:  Name: Watch Onur Mutlu’s Lectures on Digital Design and Computer Architecture  Project: RISC-V SoC  Epic: RISC-V Core  Description: Complete lecture series to understand fundamentalsStory 2:  Name: Read Harris &amp; Harris: Digital Design &amp; Computer Architecture RISC-V Edition  Project: RISC-V SoC  Epic: RISC-V Core  Description: Study the textbook chapters on RISC-V architectureStep 5: Create Tasks  Go to Tasks database  Create tasks for the Harris &amp; Harris story:Task 1:  Name: Chapter 1 - From Zero to One  Project: RISC-V SoC  Story: Read Harris &amp; Harris: Digital Design &amp; Computer Architecture RISC-V Edition  Description: Introduction to digital systems  Status: Not started  Month: Backlog  Estimated Hours: 3Task 2:  Name: Chapter 2 - Combinational Logic Design  Project: RISC-V SoC  Story: Read Harris &amp; Harris: Digital Design &amp; Computer Architecture RISC-V Edition  Status: Not started  Month: Backlog  Estimated Hours: 4Task 3:  Name: Chapter 3 - Sequential Logic Design  Project: RISC-V SoC  Story: Read Harris &amp; Harris: Digital Design &amp; Computer Architecture RISC-V Edition  Status: Not started  Month: Backlog  Estimated Hours: 4Continue creating tasks for remaining chapters…Note: The Epic column auto-populates via rollup from Story → Epic.Part 5: Sprint Planning and ExecutionPlanning Your First Sprint  Go to Tasks database  View “All Backlogs”  Filter or sort by Project: RISC-V SoC  Select tasks for January 2026 (aim for monthly capacity)  For each selected task:          Change Month: Backlog-&gt; January 2026      Change Status: Backlog -&gt; To Do      Using the Unified Kanban  Go to Tasks database  View “Current Month”  See all January 2026 tasks from all projects  Drag tasks between columns:          Not started → In progress (when starting)      In progress → Done (when complete)        Tasks are grouped by Status, sorted by ProjectDaily WorkflowMorning:  Open “Current Month” Kanban  Review all active tasks across projects  Move 1-3 tasks to “In progress”During work:  Focus on ongoing tasks  Track time manually or with timerEnd of day:  Update Actual Hours on tasks worked  Move completed tasks to “Done”  Move unstarted tasks back to “Not started” if neededEnding a Month (Sprint)  Go to “Current Month”  Select all tasks in “Not started” and “In progress”  Bulk edit: Month -&gt; February 2026  Update Kanban filter: Month -&gt; Is -&gt; February 2026",
        "url": "/productivity/using-notion-to-set-things-in-motion/",
        "date": "2025-12-06"
      }
      
    
  };
</script>

<script src="/assets/js/lunr.js"></script>

<script src="/assets/js/search.js"></script>


  </div>

</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">
    <div class="social-links">
<ul class="social-media-list">
<li>
    <a rel="me noopener noreferrer" href="https://github.com/hrvatch" target="_blank" title="Hrvoje's Github">
      <span class="grey fa-brands fa-github fa-lg"></span>
    </a>
  </li>
<li>
    <a rel="me noopener noreferrer" href="https://www.linkedin.com/in/hrvoje-butina/" target="_blank" title="Hrvoje's Linkedin profile">
      <span class="grey fa-brands fa-linkedin fa-lg"></span>
    </a>
  </li>
<li>
    <a rel="me" href="mailto:criticalpathmailto.squabble546@passmail.net" target="_blank" title="Hrvoje's E-mail">
      <span class="grey fa-regular fa-envelope fa-lg"></span>
    </a>
  </li>
  <li>
    <a href="https://criticalpath.dev/feed.xml" target="_blank" title="Subscribe to syndication feed">
      <svg class="svg-icon grey" viewbox="0 0 16 16">
        <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
          11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
          13.806c0-1.21.983-2.195 2.194-2.195zM10.606
          16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"></path>
      </svg>
    </a>
  </li>

</ul>
</div>

  </div>

</footer>


<script src="/assets/js/copy-code.js"></script>
<script src="/assets/js/search-toggle.js" defer></script>
<script src="/assets/js/theme-toggle.js" defer></script>


</body>

</html>
